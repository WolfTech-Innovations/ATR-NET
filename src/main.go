package main
import("bytes";"crypto/aes";"crypto/cipher";"crypto/ed25519";"crypto/rand";"crypto/sha256";"crypto/tls";"encoding/base64";"encoding/json";"fmt";"io";"net";"net/http";"net/url";"strings";"sync";"time")
type L struct{m sync.Mutex}
func(l*L)P(t,o,d string){l.m.Lock();defer l.m.Unlock();fmt.Printf("[%s][%s] %s\n",t,o,d)}
type ATRGarlic struct{ID string;Data[][]byte;Routes[][]string;Keys[][]byte;Timestamp int64}
type ATROnion struct{Layers[][]byte;Route[]string;SessionKey[]byte}
type ATRPacket struct{Type string;Garlic *ATRGarlic;Onion *ATROnion;Signature[]byte;NodeID string}
type ATRPeer struct{ID string;Addr string;PubKey[]byte;LastSeen time.Time;Score int}
type ATRRouter struct{peers map[string]*ATRPeer;tunnels map[string]*ATRTunnel;key ed25519.PrivateKey;pub ed25519.PublicKey;mu sync.RWMutex}
type ATRTunnel struct{ID string;Nodes[]string;Keys[][]byte;Created time.Time}
type ATRDomain struct{Domain string;RealURL string;NodeID string}
func NewATR()*ATRRouter{pub,priv,_:=ed25519.GenerateKey(rand.Reader);return&ATRRouter{make(map[string]*ATRPeer),make(map[string]*ATRTunnel),priv,pub,sync.RWMutex{}}}
func(r*ATRRouter)AddPeer(id,addr string,pk[]byte){r.mu.Lock();defer r.mu.Unlock();r.peers[id]=&ATRPeer{id,addr,pk,time.Now(),100}}
func(r*ATRRouter)GetPeers(n int)[]*ATRPeer{r.mu.RLock();defer r.mu.RUnlock();var p []*ATRPeer;for _,peer:=range r.peers{if time.Since(peer.LastSeen)<5*time.Minute{p=append(p,peer)}};if len(p)>n{p=p[:n]};return p}
func(r*ATRRouter)CreateGarlic(data[][]byte,routes[][]string)([]byte,error){keys:=make([][]byte,len(data));for i:=range keys{k:=make([]byte,32);rand.Read(k);keys[i]=k};g:=&ATRGarlic{fmt.Sprintf("g_%d",time.Now().UnixNano()),data,routes,keys,time.Now().Unix()};gd,_:=json.Marshal(g);return gd,nil}
func(r*ATRRouter)CreateOnion(data[]byte,route[]string)([]byte,error){sk:=make([]byte,32);rand.Read(sk);layers:=make([][]byte,len(route));layers[len(route)-1]=data;for i:=len(route)-2;i>=0;i--{k:=make([]byte,32);rand.Read(k);c,_:=aes.NewCipher(k);g,_:=cipher.NewGCM(c);n:=make([]byte,g.NonceSize());rand.Read(n);layers[i]=g.Seal(n,n,layers[i+1],nil)};o:=&ATROnion{layers,route,sk};od,_:=json.Marshal(o);return od,nil}
func(r*ATRRouter)ProcessATR(data[]byte,hops int)([]byte,error){peers:=r.GetPeers(hops*3);if len(peers)==0{return data,nil};routes:=make([][]string,3);for i:=0;i<3;i++{route:=make([]string,hops);for j:=0;j<hops&&j+i*hops<len(peers);j++{route[j]=peers[j+i*hops].Addr};routes[i]=route};chunks:=make([][]byte,3);cs:=len(data)/3;chunks[0]=data[:cs];chunks[1]=data[cs:cs*2];chunks[2]=data[cs*2:];gd,_:=r.CreateGarlic(chunks,routes);for i:=0;i<3;i++{od,_:=r.CreateOnion(gd,routes[i%len(routes)]);gd=od};return gd,nil}
type ATRResolver struct{domains map[string]*ATRDomain;mu sync.RWMutex}
func NewATRResolver()*ATRResolver{return&ATRResolver{make(map[string]*ATRDomain),sync.RWMutex{}}}
func(ar*ATRResolver)Register(domain,realURL,nodeID string){ar.mu.Lock();defer ar.mu.Unlock();ar.domains[domain]=&ATRDomain{domain,realURL,nodeID}}
func(ar*ATRResolver)Resolve(domain string)string{ar.mu.RLock();defer ar.mu.RUnlock();if d,ok:=ar.domains[domain];ok{return d.RealURL};return""}
type BHttpjReq struct{ID,Method,URL string;Headers map[string]string;Body[]byte;Params map[string]string;Timestamp int64}
type BHttpjResp struct{ID string;Status int;Headers map[string]string;Body[]byte;Timestamp int64}
type BHttpjNode struct{id string;atr*ATRRouter;resolver*ATRResolver;reqs map[string]*BHttpjReq;resps map[string]*BHttpjResp;mu sync.RWMutex;log*L}
func NewBHttpjNode()*BHttpjNode{return&BHttpjNode{fmt.Sprintf("n_%d",time.Now().UnixNano()),NewATR(),NewATRResolver(),make(map[string]*BHttpjReq),make(map[string]*BHttpjResp),sync.RWMutex{},&L{}}}
func(n*BHttpjNode)ParseHTTP(d string)(*BHttpjReq,error){lines:=strings.Split(d,"\r\n");if len(lines)==0{return nil,fmt.Errorf("empty")};rl:=strings.Fields(lines[0]);if len(rl)<3{return nil,fmt.Errorf("invalid")};method,rawURL:=rl[0],rl[1];pu,_:=url.Parse(rawURL);qp:=make(map[string]string);for k,v:=range pu.Query(){if len(v)>0{qp[k]=v[0]}};h:=make(map[string]string);bs:=0;for i:=1;i<len(lines);i++{if lines[i]==""{bs=i+1;break};p:=strings.SplitN(lines[i],":",2);if len(p)==2{h[strings.TrimSpace(p[0])]=strings.TrimSpace(p[1])}};var body []byte;if bs<len(lines){body=[]byte(strings.Join(lines[bs:],"\r\n"))};return&BHttpjReq{fmt.Sprintf("%s_%d",n.id,time.Now().UnixNano()),method,pu.String(),h,body,qp,time.Now().Unix()},nil}
func(n*BHttpjNode)ProcessReq(r*BHttpjReq)(*BHttpjResp,error){finalURL:=r.URL;if strings.HasSuffix(r.URL,".atr"){domain:=strings.TrimPrefix(r.URL,"http://");domain=strings.TrimPrefix(domain,"https://");parts:=strings.Split(domain,"/");if len(parts)>0&&strings.HasSuffix(parts[0],".atr"){resolved:=n.resolver.Resolve(parts[0]);if resolved!=""{finalURL=resolved;if len(parts)>1{finalURL+="/"+strings.Join(parts[1:],"/")}}else{return&BHttpjResp{r.ID,404,make(map[string]string),[]byte("ATR domain not found"),time.Now().Unix()},nil}}};if!strings.HasPrefix(finalURL,"https://"){if strings.HasPrefix(finalURL,"http://"){finalURL="https://"+finalURL[7:]}else{finalURL="https://"+finalURL}};tr:=&http.Transport{TLSClientConfig:&tls.Config{InsecureSkipVerify:false}};client:=&http.Client{Transport:tr,Timeout:30*time.Second};req,err:=http.NewRequest(r.Method,finalURL,bytes.NewBuffer(r.Body));if err!=nil{return nil,err};for k,v:=range r.Headers{req.Header.Set(k,v)};resp,err:=client.Do(req);if err!=nil{return nil,err};defer resp.Body.Close();body,_:=io.ReadAll(resp.Body);rh:=make(map[string]string);for k,v:=range resp.Header{if len(v)>0{rh[k]=v[0]}};return&BHttpjResp{r.ID,resp.StatusCode,rh,body,time.Now().Unix()},nil}
func(n*BHttpjNode)SendReq(r*BHttpjReq)error{d,_:=json.Marshal(r);pd,err:=n.atr.ProcessATR(d,3);if err!=nil{return err};n.mu.Lock();n.reqs[r.ID]=r;n.mu.Unlock();return n.sendToNetwork(pd)}
func(n*BHttpjNode)sendToNetwork(data[]byte)error{peers:=n.atr.GetPeers(1);if len(peers)==0{return fmt.Errorf("no peers")};conn,err:=net.Dial("tcp",peers[0].Addr);if err!=nil{return err};defer conn.Close();_,err=conn.Write(data);return err}
type BHttpjProxy struct{node*BHttpjNode;log*L}
func NewBHttpjProxy()*BHttpjProxy{p:=&BHttpjProxy{NewBHttpjNode(),&L{}};p.initATRDomains();return p}
func(p*BHttpjProxy)initATRDomains(){p.node.resolver.Register("search.atr","https://www.google.com","node1");p.node.resolver.Register("social.atr","https://www.twitter.com","node2");p.node.resolver.Register("video.atr","https://www.youtube.com","node3");p.node.resolver.Register("news.atr","https://news.ycombinator.com","node4");p.node.resolver.Register("code.atr","https://github.com","node5")}
func(p*BHttpjProxy)HandleHTTP(d string)(string,error){req,err:=p.node.ParseHTTP(d);if err!=nil{return"",err};err=p.node.SendReq(req);if err!=nil{return"",err};timeout:=time.After(15*time.Second);tick:=time.NewTicker(200*time.Millisecond);defer tick.Stop();for{select{case<-timeout:return"HTTP/1.1 408 Request Timeout\r\n\r\n",nil;case<-tick.C:p.node.mu.RLock();resp,ok:=p.node.resps[req.ID];p.node.mu.RUnlock();if ok{var hs strings.Builder;for k,v:=range resp.Headers{hs.WriteString(fmt.Sprintf("%s: %s\r\n",k,v))};return fmt.Sprintf("HTTP/1.1 %d OK\r\n%s\r\n%s",resp.Status,hs.String(),string(resp.Body)),nil}}}}
func(p*BHttpjProxy)handleConn(c net.Conn){defer c.Close();buf:=make([]byte,16384);n,err:=c.Read(buf);if err!=nil||n==0{return};resp,err:=p.HandleHTTP(string(buf[:n]));if err!=nil{c.Write([]byte("HTTP/1.1 500 Internal Server Error\r\n\r\n"));return};c.Write([]byte(resp))}
func(p*BHttpjProxy)Start(port int)error{l,err:=net.Listen("tcp",fmt.Sprintf("0.0.0.0:%d",port));if err!=nil{return err};p.log.P("MAIN","START",fmt.Sprintf("BHTTPJ+ATR on :%d",port));go p.startATRListener();for{c,err:=l.Accept();if err!=nil{continue};go p.handleConn(c)}}
func(p*BHttpjProxy)startATRListener(){l,err:=net.Listen("tcp","0.0.0.0:8881");if err!=nil{return};for{c,err:=l.Accept();if err!=nil{continue};go p.handleATRConn(c)}}
func(p*BHttpjProxy)handleATRConn(c net.Conn){defer c.Close();buf:=make([]byte,16384);n,err:=c.Read(buf);if err!=nil{return};var pkt ATRPacket;json.Unmarshal(buf[:n],&pkt);if pkt.Garlic!=nil{for i,chunk:=range pkt.Garlic.Data{if len(pkt.Garlic.Routes)>i&&len(pkt.Garlic.Routes[i])>0{var req BHttpjReq;json.Unmarshal(chunk,&req);resp,_:=p.node.ProcessReq(&req);p.node.mu.Lock();p.node.resps[resp.ID]=resp;p.node.mu.Unlock()}}}}
func main(){proxy:=NewBHttpjProxy();proxy.node.atr.AddPeer("p1","127.0.0.1:8882",[]byte("peer1"));proxy.node.atr.AddPeer("p2","127.0.0.1:8883",[]byte("peer2"));proxy.node.atr.AddPeer("p3","127.0.0.1:8884",[]byte("peer3"));err:=proxy.Start(8888);if err!=nil{proxy.log.P("MAIN","ERROR",err.Error())}}
