package main
import("bytes";"crypto/aes";"crypto/cipher";"crypto/rand";"crypto/sha256";"encoding/base64";"encoding/json";"fmt";"io";"math/big";"net";"net/http";"sync";"time";"os/exec";"log")
type Logger struct{mu sync.Mutex}
func(l*Logger)Log(layer,op,details string,extra ...string){l.mu.Lock();defer l.mu.Unlock();ts:=time.Now().Format("2006-01-02 15:04:05.000");fmt.Printf("[\033[1;36m%s\033[0m] [\033[1;33m%s\033[0m] [\033[1;32m%s\033[0m] %s",ts,layer,op,details);for _,e:=range extra{fmt.Printf(" | %s",e)};fmt.Println()}
type BHttpjRequest struct{ID,Method,URL,AuthToken string;Headers map[string]string;Body[]byte;Timestamp int64}
type BHttpjResponse struct{ID string;Status int;Headers map[string]string;Body[]byte;Timestamp int64;AuthToken string}
type BlockchainBlock struct{Index uint64;Timestamp int64;Data[]byte;PreviousHash,Hash string;Nonce uint64}
type BHttpjBlockchain struct{Blocks[]BlockchainBlock;Difficulty int;mu sync.RWMutex}
func NewBlockchain()*BHttpjBlockchain{g:=BlockchainBlock{0,time.Now().Unix(),[]byte("genesis"),"0","0",0};return&BHttpjBlockchain{[]BlockchainBlock{g},4}}
func(bc*BHttpjBlockchain)CalculateHash(b*BlockchainBlock)string{h:=sha256.New();h.Write([]byte(fmt.Sprintf("%d%d%s%s%d",b.Index,b.Timestamp,b.Data,b.PreviousHash,b.Nonce)));return base64.StdEncoding.EncodeToString(h.Sum(nil))}
func(bc*BHttpjBlockchain)MineBlock(b BlockchainBlock)BlockchainBlock{t:="";for i:=0;i<bc.Difficulty;i++{t+="0"};for{b.Hash=bc.CalculateHash(&b);if len(b.Hash)>=bc.Difficulty&&b.Hash[:bc.Difficulty]==t{break};b.Nonce++};return b}
func(bc*BHttpjBlockchain)AddBlock(data[]byte){bc.mu.Lock();defer bc.mu.Unlock();p:=&bc.Blocks[len(bc.Blocks)-1];b:=BlockchainBlock{p.Index+1,time.Now().Unix(),data,p.Hash,"",0};bc.Blocks=append(bc.Blocks,bc.MineBlock(b))}
func(bc*BHttpjBlockchain)EncryptChain()([]byte,error){bc.mu.RLock();defer bc.mu.RUnlock();d,err:=json.Marshal(bc);if err!=nil{return nil,err};h:=sha256.Sum256(d);bl,err:=aes.NewCipher(h[:]);if err!=nil{return nil,err};g,err:=cipher.NewGCM(bl);if err!=nil{return nil,err};n:=make([]byte,g.NonceSize());e:=g.Seal(n,n,d,nil);return[]byte(base64.StdEncoding.EncodeToString(e)),nil}
type ObfsConnection struct{}
func NewObfsConnection()*ObfsConnection{return&ObfsConnection{}}
func(oc*ObfsConnection)Obfuscate(in[]byte)[]byte{r:=make([]byte,0,len(in)*3);for _,b:=range in{r=append(r,b^0xAA);rb:=make([]byte,1);rand.Read(rb);r=append(r,rb[0]);r=append(r,(b+0x33)^0x55)};return r}
func(oc*ObfsConnection)Deobfuscate(in[]byte)[]byte{r:=make([]byte,0,len(in)/3);for i:=0;i<len(in);i+=3{if i+2<len(in){r=append(r,in[i]^0xAA)}};return r}
func(oc*ObfsConnection)ObfuscateBlockchain(d[]byte)[]byte{h:=sha256.Sum256(d);o:=oc.Obfuscate(d);o=append(o,h[:]...);return[]byte(base64.StdEncoding.EncodeToString(o))}
type SnowflakeConnection struct{peers[]string}
func NewSnowflakeConnection()*SnowflakeConnection{return&SnowflakeConnection{[]string{"127.0.0.1:8888"}}}
func(sc*SnowflakeConnection)Relay(d[]byte)([]byte,error){c,err:=net.Dial("tcp",sc.peers[0]);if err!=nil{return nil,err};defer c.Close();_,err=c.Write(d);if err!=nil{return nil,err};b:=make([]byte,8192);n,err:=c.Read(b);return b[:n],err}
type BitTorrentNode struct{peerID[20]byte;peers map[[20]byte]string;requests map[string]*BHttpjRequest;responses map[string]*BHttpjResponse;sessions map[string]string;blockchain*BHttpjBlockchain;mu sync.RWMutex}
func NewBitTorrentNode()*BitTorrentNode{var p[20]byte;rand.Read(p[:]);return&BitTorrentNode{p,make(map[[20]byte]string),make(map[string]*BHttpjRequest),make(map[string]*BHttpjResponse),make(map[string]string),NewBlockchain(),sync.RWMutex{}}}
func(btn*BitTorrentNode)GenerateAuthToken(url string)string{h:=sha256.Sum256([]byte(url));return base64.StdEncoding.EncodeToString(h[:])}
func(btn*BitTorrentNode)ValidateToken(url,token string)bool{return btn.GenerateAuthToken(url)==token}
func(btn*BitTorrentNode)AddToBlockchain(data[]byte){btn.blockchain.AddBlock(data)}
func(btn*BitTorrentNode)GetBlockchainData()([]byte,error){return btn.blockchain.EncryptChain()}
func(btn*BitTorrentNode)SendRequest(req*BHttpjRequest)error{d,err:=json.Marshal(req);if err!=nil{return err};btn.AddToBlockchain(d);b,err:=btn.GetBlockchainData();if err!=nil{return err};p:=BHttpjPacket{"request",d,btn.peerID,[20]byte{},b};pd,err:=json.Marshal(p);if err!=nil{return err};btn.mu.Lock();btn.requests[req.ID]=req;btn.mu.Unlock();for _,a:=range btn.peers{c,err:=net.Dial("tcp",a);if err!=nil{continue};c.Write(pd);c.Close()};return nil}
func(btn*BitTorrentNode)HandlePacket(pd[]byte)error{var p BHttpjPacket;err:=json.Unmarshal(pd,&p);if err!=nil{return err};switch p.ReqType{case"request":var r BHttpjRequest;err:=json.Unmarshal(p.Data,&r);if err!=nil{return err};if!btn.ValidateToken(r.URL,r.AuthToken){return nil};resp,err:=btn.ProcessHTTPRequest(&r);if err!=nil{return err};rd,_:=json.Marshal(resp);btn.AddToBlockchain(rd);b,_:=btn.GetBlockchainData();rp:=BHttpjPacket{"response",rd,btn.peerID,p.InfoHash,b};rpd,_:=json.Marshal(rp);for _,a:=range btn.peers{c,err:=net.Dial("tcp",a);if err!=nil{continue};c.Write(rpd);c.Close();break};case"response":var r BHttpjResponse;err:=json.Unmarshal(p.Data,&r);if err!=nil{return err};if!btn.ValidateToken("response",r.AuthToken){return nil};btn.mu.Lock();btn.responses[r.ID]=&r;btn.mu.Unlock()};return nil}
func(btn*BitTorrentNode)ProcessHTTPRequest(req*BHttpjRequest)(*BHttpjResponse,error){client:=&http.Client{Timeout:30*time.Second};rq,err:=http.NewRequest(req.Method,req.URL,bytes.NewBuffer(req.Body));if err!=nil{return nil,err};for k,v:=range req.Headers{rq.Header.Set(k,v)};resp,err:=client.Do(rq);if err!=nil{return nil,err};defer resp.Body.Close();body,err:=io.ReadAll(resp.Body);if err!=nil{return nil,err};h:=make(map[string]string);for k,v:=range resp.Header{if len(v)>0{h[k]=v[0]}};t:=btn.GenerateAuthToken(req.URL);btn.mu.Lock();btn.sessions[req.URL]=t;btn.mu.Unlock();return&BHttpjResponse{req.ID,resp.StatusCode,h,body,time.Now().Unix(),t},nil}
type BHttpjPacket struct{ReqType string;Data[]byte;PeerID,InfoHash[20]byte;Blockchain[]byte}
type BHttpjProxy struct{btNode*BitTorrentNode;obfs*ObfsConnection;snowflake*SnowflakeConnection;logger*Logger}
func NewBHttpjProxy()*BHttpjProxy{return&BHttpjProxy{NewBitTorrentNode(),NewObfsConnection(),NewSnowflakeConnection(),&Logger{}}}
func(bp*BHttpjProxy)InitConnections()error{bp.logger.Log("PROXY","INIT","Connections initialized");return nil}
func(bp*BHttpjProxy)ConvertToBHttpj(httpData string)(*BHttpjRequest,error){lines:=bytes.Split([]byte(httpData),[]byte("\r\n"));if len(lines)==0{return nil,fmt.Errorf("empty req")};fl:=string(lines[0]);parts:=bytes.Fields([]byte(fl));if len(parts)<2{return nil,fmt.Errorf("missing method/url")};m:=string(parts[0]);u:=string(parts[1]);h:=make(map[string]string);bStart:=0;for i:=1;i<len(lines);i++{l:=string(lines[i]);if l==""{bStart=i+1;break};hp:=bytes.SplitN([]byte(l),[]byte(":"),2);if len(hp)==2{h[string(bytes.TrimSpace(hp[0]))]=string(bytes.TrimSpace(hp[1]))}};var b[]byte;if bStart<len(lines){b=bytes.Join(lines[bStart:],[]byte("\n"))};idInt,err:=rand.Int(rand.Reader,big.NewInt(1000000));if err!=nil{return nil,err};t:=bp.btNode.GenerateAuthToken(u);return &BHttpjRequest{fmt.Sprintf("%d",idInt),m,u,t,h,b,time.Now().Unix()},nil}
func(bp*BHttpjProxy)ProcessLayers(data[]byte)([]byte,error){st:=time.Now();sd,err:=bp.snowflake.Relay(data);if err!=nil{bp.logger.Log("PROXY","ERROR","Snowflake relay failed",err.Error());return nil,err};bd,err:=bp.btNode.GetBlockchainData();if err!=nil{bp.logger.Log("PROXY","ERROR","BlockchainData failed",err.Error());return nil,err};obfsd:=bp.obfs.ObfuscateBlockchain(bd);obfsData:=bp.obfs.Obfuscate(sd);comb:=append(obfsData,obfsd...);dur:=time.Since(st);bp.logger.Log("PROXY","LAYERS","ProcessLayers complete",fmt.Sprintf("dur=%v",dur));return comb,nil}
func(bp*BHttpjProxy)HandleWebRequest(httpRequest string)(string,error){bp.logger.Log("PROXY","REQ","Received request",httpRequest);bhttpjReq,err:=bp.ConvertToBHttpj(httpRequest);if err!=nil{bp.logger.Log("PROXY","ERROR","ConvertToBHttpj",err.Error());return"",err};reqJSON,err:=json.Marshal(bhttpjReq);if err!=nil{bp.logger.Log("PROXY","ERROR","Marshal",err.Error());return"",err};start:=time.Now();_,err=bp.ProcessLayers(reqJSON);if err!=nil{bp.logger.Log("PROXY","ERROR","Layers",err.Error());return"",err};err=bp.btNode.SendRequest(bhttpjReq);if err!=nil{bp.logger.Log("PROXY","ERROR","SendRequest",err.Error());return"",err};timeout:=time.After(5*time.Second);tick:=time.Tick(100*time.Millisecond);for{select{case<-timeout:bp.logger.Log("PROXY","TIMEOUT","No response",bhttpjReq.ID);return"HTTP/1.1 408 Request Timeout\r\n\r\n",nil;case<-tick:bp.btNode.mu.RLock();resp,exists:=bp.btNode.responses[bhttpjReq.ID];bp.btNode.mu.RUnlock();if exists{dur:=time.Since(start);bp.logger.Log("PROXY","SUCCESS",fmt.Sprintf("Status:%d bytes:%d in %v",resp.Status,len(resp.Body),dur),bhttpjReq.ID);return fmt.Sprintf("HTTP/1.1 %d OK\r\nContent-Type: text/html\r\nContent-Length: %d\r\n\r\n%s",resp.Status,len(resp.Body),resp.Body),nil}}}}
func(bp*BHttpjProxy)handleConnection(conn net.Conn){defer conn.Close();addr:=conn.RemoteAddr().String();buffer:=make([]byte,16384);n,err:=conn.Read(buffer);if err!=nil||n==0{bp.logger.Log("PROXY","ERROR","Read fail/empty",addr);return};req:=string(buffer[:n]);bp.logger.Log("PROXY","CLIENT","Request from",addr,req);start:=time.Now();resp,err:=bp.HandleWebRequest(req);dur:=time.Since(start);if err!=nil{bp.logger.Log("PROXY","RESPERR",fmt.Sprintf("To %s in %v",addr,dur),err.Error());conn.Write([]byte("HTTP/1.1 500 Internal Server Error\r\n\r\n"));return};bp.logger.Log("PROXY","RESPOND",fmt.Sprintf("To %s %d bytes in %v",addr,len(resp),dur));conn.Write([]byte(resp))}
func(bp*BHttpjProxy)StartServer(port int)error{l,err:=net.Listen("tcp",fmt.Sprintf("0.0.0.0:%d",port));if err!=nil{return err};bp.logger.Log("MAIN","START","Listening",fmt.Sprintf("0.0.0.0:%d",port));bp.InitConnections();go bp.startBitTorrentListener();for{c,err:=l.Accept();if err!=nil{bp.logger.Log("PROXY","ERROR","Accept fail",err.Error());continue};go bp.handleConnection(c)}}
func(bp*BHttpjProxy)startBitTorrentListener(){l,err:=net.Listen("tcp","0.0.0.0:6881");if err!=nil{bp.logger.Log("BT","ERROR","Listen fail",err.Error());return};bp.logger.Log("BT","START","Listening","0.0.0.0:6881");for{c,err:=l.Accept();if err!=nil{bp.logger.Log("BT","ERROR","Accept fail",err.Error());continue};go func(conn net.Conn){defer conn.Close();b:=make([]byte,16384);n,err:=conn.Read(b);if err!=nil{bp.logger.Log("BT","ERROR","Read fail",err.Error());return};bp.logger.Log("BT","PKT","Packet recv",fmt.Sprintf("%d bytes",n));bp.btNode.HandlePacket(b[:n])}(c)}}
func main(){proxy:=NewBHttpjProxy();err:=proxy.StartServer(8888);if err!=nil{proxy.logger.Log("MAIN","ERROR","Startup",err.Error())}}